package com.myobexercise.payslip.service.payslip.batch.file;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.databind.ObjectWriter;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.dataformat.csv.CsvGenerator.Feature;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.myobexercise.payslip.domain.payslip.IncomeItem;
import com.myobexercise.payslip.domain.payslip.Payslip;
import com.myobexercise.payslip.domain.payslip.PercentageDeserializer;
import com.myobexercise.payslip.domain.payslip.batch.PayslipBatch;

import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.Validator;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

@Service
public class CsvBatchFileService {

	protected static final String PAYSLIPS_FILE_PREFIX = "payslips-";

	public CsvBatchFileService() {
		super();
	}

	@Autowired
	private Validator validator;

	public Validator getValidator() {
		return validator;
	}

	public void setValidator(Validator validator) {
		this.validator = validator;
	}

	/**
	 * Parses the CSV file and constructs a {@link PayslipBatch}. This is the inverse of the
	 * {@link #createFileContentsForPayslipBatch(PayslipBatch)} method.
	 * 
	 * @param file {@link MultipartFile} in CSV format.
	 * @return the {@link PayslipBatch} generated by processing the CSV file.
	 * @see CsvBatchFileService#createFileContentsForPayslipBatch(PayslipBatch)
	 */
	public PayslipBatch constructPayslipBatch(MultipartFile file) {
		PayslipBatch payslipBatch = new PayslipBatch();
		payslipBatch.setBatchName(determineBatchName(file.getOriginalFilename()));
		payslipBatch.setIncomeItems(parseFileForIncomeItems(file));
		return payslipBatch;
	}

	/**
	 * Deconstructs the {@link PayslipBatch} and creates the CSV file content based on the batch
	 * {@link PayslipBatch#getPayslips()} children. This is the inverse of the
	 * {@link #constructPayslipBatch(MultipartFile)} method.
	 * 
	 * @param payslipBatch The {@link PayslipBatch} to deconstruct.
	 * @return The CSV file content based on the {@link PayslipBatch}.
	 * @see #constructPayslipBatch(MultipartFile)
	 */
	public String createFileContentsForPayslipBatch(PayslipBatch payslipBatch) {
		ObjectWriter objectWriter = constructCsvObjectWriter();
		StringBuilder stringBuilder = new StringBuilder();
		payslipBatch.getPayslips().stream().forEachOrdered(p -> {
			try {
				stringBuilder.append(objectWriter.writeValueAsString(p));
				stringBuilder.append(System.lineSeparator());
			} catch (JsonProcessingException e) {
				throw new BatchFileException("Problem writing CSV data for ");
			}
		});

		return stringBuilder.toString();
	}

	protected ObjectWriter constructCsvObjectWriter() {
		CsvMapper csvMapper = new CsvMapper();
		csvMapper.configure(Feature.ALWAYS_QUOTE_STRINGS, false);
		ObjectWriter objectWriter = csvMapper.writerWithSchemaFor(Payslip.class);
		return objectWriter;
	}

	protected String determineBatchName(String batchName) {
		StringBuilder batchFilename = new StringBuilder(PAYSLIPS_FILE_PREFIX);
		batchName = StringUtils.cleanPath(batchName);
		if (StringUtils.isEmpty(batchName)) {
			batchFilename
					.append(LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMddHHmmSSSSS")));
			batchFilename.append(".csv");
		} else {
			batchFilename.append(batchName);
		}

		return batchFilename.toString();
	}

	protected List<IncomeItem> parseFileForIncomeItems(MultipartFile file) {
		CsvMapper csvMapper = new CsvMapper();

		MappingIterator<IncomeItem> mappingIterator;
		List<IncomeItem> incomeItems;
		try {
			mappingIterator = constructCsvMappingIterator(file, csvMapper);
			incomeItems = mappingIterator.readAll();
		} catch (

		JsonProcessingException e) {
			throw new BatchFileException("Problem parsing CSV data.", e);
		} catch (IOException e) {
			throw new BatchFileException("Problem reading CSV file.", e);
		}

		validateIncomeItems(incomeItems);

		return incomeItems;
	}

	protected MappingIterator<IncomeItem> constructCsvMappingIterator(MultipartFile file,
			CsvMapper csvMapper) throws IOException, JsonProcessingException {
		MappingIterator<IncomeItem> mappingIterator;
		CsvSchema csvSchema = csvMapper.schemaFor(IncomeItem.class);
		csvMapper.addMixIn(IncomeItem.class, IncomeItemCsvMixIn.class);

		mappingIterator = csvMapper.reader(csvSchema).forType(IncomeItem.class)
				.readValues(new InputStreamReader(file.getInputStream()));
		return mappingIterator;
	}

	protected void validateIncomeItems(List<IncomeItem> incomeItems) {
		incomeItems.stream().forEachOrdered(i -> validateIncomeItem(i));
	}

	protected void validateIncomeItem(IncomeItem incomeItem) {
		Set<ConstraintViolation<IncomeItem>> validate = validator.validate(incomeItem);
		raiseValidationExceptionIfErrorsFound(validate);
	}

	protected void raiseValidationExceptionIfErrorsFound(
			Set<ConstraintViolation<IncomeItem>> validate) {
		if (validate.size() > 0) {
			// TODO Need to make this more descriptive
			throw new BatchFileException(
					"Problem with Income Item.  " + validate.iterator().next().getMessage());
		}
	}

	class IncomeItemCsv extends IncomeItem {
	}

	class IncomeItemCsvMixIn extends IncomeItem {
		@Override
		@JsonDeserialize(using = PercentageDeserializer.class)
		public BigDecimal getSuperannuationRate() {
			return super.getSuperannuationRate();
		}
	}

}
